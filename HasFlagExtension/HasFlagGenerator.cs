using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Xunit.Abstractions;

namespace HasFlagExtension;

[Generator]
public class HasFlagGenerator : IIncrementalGenerator {

    private readonly ITestOutputHelper? _testOutputHelper;
    
    public HasFlagGenerator(ITestOutputHelper? testOutputHelper = null) {
        _testOutputHelper = testOutputHelper;
    }
    
    public HasFlagGenerator() { }
    
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        
        // Gather all enum declarations
        var enumDeclarations = context.SyntaxProvider.CreateSyntaxProvider(
            static (node, _) => node is EnumDeclarationSyntax,
            static (ctx, _) => (EnumDeclarationSyntax)ctx.Node
        );

        // Combine with compilation to inspect attributes and symbols
        var flaggedEnums = context.CompilationProvider.Combine(enumDeclarations.Collect())
            .Select(static (pair, _) => {
                var (compilation, enums) = pair;
                var result = ImmutableArray.CreateBuilder<FlagEnumInfo>();

                foreach (var ed in enums.Distinct()) {
                    var model = compilation.GetSemanticModel(ed.SyntaxTree);
                    if (model.GetDeclaredSymbol(ed) is not { } enumSymbol)
                        continue;

                    // Must be an enum with [Flags]
                    if (enumSymbol.TypeKind != TypeKind.Enum)
                        continue;

                    var hasFlags = enumSymbol.GetAttributes().Any(a =>
                        a.AttributeClass?.ToDisplayString() is "System.FlagsAttribute" or "FlagsAttribute");

                    if (!hasFlags)
                        continue;

                    // Detect prefix attribute
                    var prefixAttribute = enumSymbol
                        .GetAttributes()
                        .FirstOrDefault(
                            a => a.AttributeClass?.ToDisplayString() is 
                                "HasFlagPrefixAttribute" or "HasFlagExtension.HasFlagPrefixAttribute"
                        );

                    string? prefix = null;
                    if (prefixAttribute is not null && prefixAttribute.ConstructorArguments.Length > 0) {
                        var rawPrefix = prefixAttribute.ConstructorArguments[0].Value;
                        prefix = rawPrefix as string ?? rawPrefix?.ToString();
                    }
                    
                    // Collect enum members (exclude special ones without constant value)
                    var members = enumSymbol.GetMembers()
                        .OfType<IFieldSymbol>()
                        .Where(f => f.HasConstantValue && f.ConstantValue is not null)
                        .Select(f => new EnumMemberInfo(f.Name, f.ConstantValue))
                        .ToImmutableArray();

                    if (members.Length == 0)
                        continue;

                    result.Add(new FlagEnumInfo(enumSymbol, members, prefix));
                }

                return result.ToImmutable();
            });

        // Generate one file per enum
        context.RegisterSourceOutput(flaggedEnums, (spc, enums) => {
            foreach (var e in enums) {
                var source = GenerateExtensionsSource(e, _testOutputHelper);
                spc.AddSource($"{e.SymbolName}Extensions.g.cs", source);
                Console.WriteLine(source + '\n');
            }
        });
    }

    private static string GenerateExtensionsSource(FlagEnumInfo info, ITestOutputHelper? testOutputHelper = null) {
        var ns = info.Namespace;
        var enumName = info.SymbolName;
        var extTypeName = enumName + "Extensions";
        
        testOutputHelper?.WriteLine(info.Prefix);

        var sb = new StringBuilder();
        sb.AppendLine($"""
                       // <auto-generated/>
                       
                       using System; 
                       using System.Diagnostics.Contracts;
                       
                       """);
        
        if (!string.IsNullOrEmpty(ns)) {
            sb.AppendLine($"namespace {ns} {{");
            sb.AppendLine();
        }

        sb.AppendLine($$"""
                            public static partial class {{extTypeName}} {
                        """);
        
        // Generate methods: public static bool HasFlag{Name}(this EnumType value)
        foreach (var m in info.Members) {
            var methodName = info.Prefix + SafeIdentifier(m.Name);
            
            sb.AppendLine($"""
                           
                                   /// <summary>
                                   /// Returns true if any of the bits for {m.Name} are set in the value.
                                   /// </summary>
                                   [Pure]
                                   public static bool Get{methodName}(this {enumName} value) => value.HasFlag({enumName}.{m.Name});
                           """);
        }

        // Generate Extension Members
        sb.AppendLine($$"""
                        
                        #if NET10_0_OR_GREATER
                        
                                extension({{enumName}} value) {
                        """);

        foreach (var m in info.Members) {
            var propertyName = info.Prefix + SafeIdentifier(m.Name);

            sb.AppendLine($"""
                           
                                       /// <summary>
                                       /// Returns true if any of the bits for {m.Name} are set in the value.
                                       /// </summary>
                                       public bool {propertyName} => value.HasFlag({enumName}.{m.Name});
                           """);
        }

        sb.AppendLine("""
                              }
                      
                      #endif
                      
                      """);
        
        sb.AppendLine("    }");
        if (!string.IsNullOrEmpty(ns)) {
            sb.Append("}");
        }

        return sb.ToString();
    }

    private static string SafeIdentifier(string name) {
        // Basic sanitization for identifiers conflicting with keywords or containing invalid chars
        // Keywords list is limited; prepend @ if needed and strip invalid chars.
        if (SyntaxFacts.GetKeywordKind(name) != SyntaxKind.None ||
            SyntaxFacts.GetContextualKeywordKind(name) != SyntaxKind.None)
        {
            return "@" + name;
        }

        // Replace invalid identifier chars with underscore
        var sb = new StringBuilder(name.Length);
        for (int i = 0; i < name.Length; i++) {
            var ch = name[i];
            if (i == 0 ? SyntaxFacts.IsIdentifierStartCharacter(ch) : SyntaxFacts.IsIdentifierPartCharacter(ch))
                sb.Append(ch);
            else
                sb.Append('_');
        }
        
        var id = sb.ToString();
        if (string.IsNullOrEmpty(id) || !SyntaxFacts.IsIdentifierStartCharacter(id[0]))
            id = "_" + id;
        return id;
    }

    private readonly record struct EnumMemberInfo(string Name, object? ConstantValue) {
        public string Name { get; } = Name;
        public object? ConstantValue { get; } = ConstantValue;
    }

    private readonly record struct FlagEnumInfo(INamedTypeSymbol Symbol, ImmutableArray<EnumMemberInfo> Members, string? Prefix = null) {
        private readonly string? _prefix = Prefix;

        public string Namespace => Symbol.ContainingNamespace?.IsGlobalNamespace == false
            ? Symbol.ContainingNamespace.ToDisplayString()
            : string.Empty;
        public string SymbolName => Symbol.Name;
        public INamedTypeSymbol Symbol { get; } = Symbol;
        public ImmutableArray<EnumMemberInfo> Members { get; } = Members;

        public string Prefix => _prefix ?? "Has";
    }
}