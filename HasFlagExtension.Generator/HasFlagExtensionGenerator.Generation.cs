// HasFlagExtension Generator
// Copyright (c) 2025 KryKom

using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace HasFlagExtension.Generator;

[Generator]
public partial class HasFlagExtensionGenerator :  IIncrementalGenerator {
    
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        
        var incrNaming = context.CompilationProvider.Select(static (compilation, _) => {
            var enumNamingAttribute = compilation.Assembly
                .GetAttributes()
                .FirstOrDefault(attr => 
                    attr.AttributeClass?.ToDisplayString() == $"{HFNS}.{nameof(EnumNamingAttribute)}");
        
            return AnalyzeNaming(enumNamingAttribute);
        });
        
        // Gather all enum declarations
        var enumDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is EnumDeclarationSyntax,
                static (ctx, _) => {
                    var enumSyntax    = (EnumDeclarationSyntax)ctx.Node;
                    var semanticModel = ctx.SemanticModel;
                        
                    // Get the symbol for the enum
                    var enumSymbol = semanticModel.GetDeclaredSymbol(enumSyntax) as INamedTypeSymbol;
                    if (enumSymbol is null) return null;
                        
                    // Check if it has the FlagsAttribute
                    var hasFlagsAttribute = enumSymbol.GetAttributes()
                        .Any(attr => attr.AttributeClass?.ToDisplayString() == "System.FlagsAttribute");
                        
                    return hasFlagsAttribute ? enumSyntax : null;
                })
            .Where(static e => e is not null)
            .Combine(context.CompilationProvider)
            .Select(static (data, _) => AnalyzeEnum(data.Left!, data.Right));

        var combined = enumDeclarations.Combine(incrNaming);

        context.RegisterSourceOutput(incrNaming, (spc, result) => {
            foreach (var d in result.Diagnostics) {
                spc.ReportDiagnostic(d);
            }
        });
        
        context.RegisterSourceOutput(combined, Generate);
        
        return;

        static void Generate(SourceProductionContext spc, (EnumGenResult Left, EnumNamingAnalysisResult Right) data) {
            var naming  = data.Right;
            var enumRes = data.Left;

            foreach (var d in enumRes.Diagnostics) spc.ReportDiagnostic(d);

            if (enumRes.Info is null) return;

            var enumInfo = enumRes.Info.Value;

            if (enumInfo.Exclude) return;

            spc.AddSource($"{enumInfo.Name}Extensions.g.cs", GenerateSourceFile(enumInfo, naming.Naming));
        }
    }

    private static string GenerateSourceFile(EnumInfo info, EnumNamingInfo naming) {
        var ns           = info.Namespace;
        var enumName     = info.Name;
        var fullEnumName = info.FullName;
        var extTypeName  = enumName + "Extensions";
        var am           = info.Access == Accessibility.Public ? "public" : "internal";
        var prefix       = info.Prefix;

        const string paramName = "val";
        
        var sb = new StringBuilder();

        sb.AppendLine(
            $$"""
            // <auto-generated />
            
            using System.Diagnostics.Contracts;
            using System.Runtime.CompilerServices;
            using {{ns}};
            
            namespace {{ns}};
            
            {{am}} static partial class {{extTypeName}} {          
            """);

        foreach (var m in info.Members) {
            if (m.Exclude) continue;
            
            var name = prefix + (m.HasCustomName 
                ? m.DisplayName 
                : NameConvertor.Convert(m.Name, (info.Naming ?? naming)));

            sb.AppendLine(
                $"""
                
                    /// <summary>
                    /// Returns true if the flag {m.Name} is present in the value.
                    /// </summary>
                    [Pure]
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    {am} static bool Get{name}(this {fullEnumName} {paramName}) => {paramName}.HasFlag({fullEnumName}.{m.Name});
                """);
        }
        
        sb.AppendLine(
            $$"""
            
            #if NET10_0_OR_GREATER
            
                extension ({{fullEnumName}} {{paramName}}) {
            """);
        
        foreach (var m in info.Members) {
            if (m.Exclude) continue;
            
            var name = prefix + (m.HasCustomName 
                ? m.DisplayName 
                : NameConvertor.Convert(m.Name, (info.Naming ?? naming)));

            sb.AppendLine(
                $"""

                         /// <summary>
                         /// Returns true if the flag {m.Name} is present in the value.
                         /// </summary>
                         [Pure]
                         {am} bool {name} => {paramName}.HasFlag({fullEnumName}.{m.Name});
                 """);
        }

        sb.Append(
            """
                }
            #endif
            
            }
            """);
        
        return sb.ToString();
    }
}