// HasFlagExtension Generator
// Copyright (c) 2025 KryKom

using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace HasFlagExtension.Generator;

[Generator]
public partial class HasFlagExtensionGenerator :  IIncrementalGenerator {
    
    private const string HFNS = nameof(HasFlagExtension);
    
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        
        // Add Attributes.g.cs
        context.RegisterPostInitializationOutput(ctx => {
            var          assembly     = Assembly.GetExecutingAssembly();
            const string resourceName = $"{HFNS}.Generator.Templates.Attributes.cs";
            
            using var stream = assembly.GetManifestResourceStream(resourceName);
            if (stream == null)
                return;

            using var reader  = new StreamReader(stream);
            var       content = reader.ReadToEnd();
            
            // Add the source to the compilation
            ctx.AddSource("HasFlagExtension.Attributes.g.cs", SourceText.From(content, Encoding.UTF8));
        });
        
        // Add NamingCase.g.cs
        context.RegisterPostInitializationOutput(ctx => {
            var          assembly     = Assembly.GetExecutingAssembly();
            const string resourceName = $"{HFNS}.Generator.Templates.NamingCase.cs";
            
            using var stream = assembly.GetManifestResourceStream(resourceName);
            if (stream == null)
                return;

            using var reader  = new StreamReader(stream);
            var             content = reader.ReadToEnd();
            
            // Add the source to the compilation
            ctx.AddSource("HasFlagExtension.NamingCase.g.cs", SourceText.From(content, Encoding.UTF8));
        });
        
        var incrNaming = context.CompilationProvider.Select(static (compilation, _) => {
            var enumNamingAttribute = compilation.Assembly
                .GetAttributes()
                .FirstOrDefault(attr => 
                    attr.AttributeClass?.ToDisplayString() == $"{HFNS}.{nameof(EnumNamingAttribute)}");
        
            return AnalyzeNaming(enumNamingAttribute);
        });
        
        // Gather all enum declarations
        var enumDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is EnumDeclarationSyntax,
                static (ctx, _) => {
                    var enumSyntax    = (EnumDeclarationSyntax)ctx.Node;
                    var semanticModel = ctx.SemanticModel;
                        
                    // Get the symbol for the enum
                    var enumSymbol = semanticModel.GetDeclaredSymbol(enumSyntax) as INamedTypeSymbol;
                    if (enumSymbol is null) return null;
                        
                    // Check if it has the FlagsAttribute
                    var hasFlagsAttribute = enumSymbol.GetAttributes()
                        .Any(attr => attr.AttributeClass?.ToDisplayString() == "System.FlagsAttribute");
                        
                    return hasFlagsAttribute ? enumSyntax : null;
                })
            .Where(static e => e is not null)
            .Combine(context.CompilationProvider)
            .Select(static (data, _) => AnalyzeEnum(data.Left!, data.Right));

        var combined = enumDeclarations.Combine(incrNaming);

        context.RegisterSourceOutput(combined, Generate);
        
        return;

        static void Generate(SourceProductionContext spc, (EnumGenResult Left, EnumNamingAnalysisResult Right) data) {
            var naming  = data.Right;
            var enumRes = data.Left;

            foreach (var d in naming.Diagnostics) spc.ReportDiagnostic(d);
            foreach (var d in enumRes.Diagnostics) spc.ReportDiagnostic(d);

            if (enumRes.Info is null) return;

            var enumInfo = enumRes.Info.Value;

            if (enumInfo.Exclude) return;

            spc.AddSource($"{enumInfo.Name}Extensions.g.cs", GenerateSourceFile(enumInfo, naming.Naming));
        }
    }

    private static string GenerateSourceFile(EnumInfo info, EnumNamingInfo naming) {
        var ns           = info.Namespace;
        var enumName     = info.Name;
        var fullEnumName = info.FullName;
        var extTypeName  = enumName + "Extensions";
        var am           = info.Access == Accessibility.Public ? "public" : "internal";
        var prefix       = info.Prefix;

        const string paramName = "val";
        
        var sb = new StringBuilder();

        sb.AppendLine(
            $$"""
            // <auto-generated />
            
            using {{ns}};
            
            namespace {{ns}};
            
            {{am}} static class {{extTypeName}} {          
            """);

        foreach (var m in info.Members) {
            if (m.Exclude) continue;
            
            var name = prefix + (m.HasCustomName 
                ? m.DisplayName 
                : NameConvertor.Convert(m.Name, (info.Naming ?? naming)));

            sb.AppendLine(
                $"""
                
                    /// <summary>
                    /// Returns true if the flag {m.Name} is on in the value.
                    /// </summary>
                    {am} static bool Get{name}(this {fullEnumName} {paramName}) => {paramName}.HasFlag({fullEnumName}.{m.Name});
                """);
        }
        
        sb.AppendLine(
            $$"""
                #if NET10_0_OR_GREATER
            
                extension ({{fullEnumName}} {{paramName}}) {
            """);
        
        foreach (var m in info.Members) {
            if (m.Exclude) continue;
            
            var name = prefix + (m.HasCustomName 
                ? m.DisplayName 
                : NameConvertor.Convert(m.Name, (info.Naming ?? naming)));

            sb.AppendLine(
                $"""

                         /// <summary>
                         /// Returns true if the flag {m.Name} is on in the value.
                         /// </summary>
                         {am} bool {name} => {paramName}.HasFlag({fullEnumName}.{m.Name});
                 """);
        }

        sb.AppendLine(
            """
                }
                
                #endif
            }
            """);
        
        return sb.ToString();
    }
}