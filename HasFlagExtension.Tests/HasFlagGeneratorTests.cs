// HasFlagExtension Generator
// Copyright (c) 2025 KryKom

using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;
using Xunit.Abstractions;

namespace HasFlagExtension.Tests;

public class HasFlagGeneratorTests {
    private readonly ITestOutputHelper _testOutputHelper;
    public HasFlagGeneratorTests(ITestOutputHelper testOutputHelper) {
        _testOutputHelper = testOutputHelper;
    }
    

    private string GetTestEnumClass(string prefix) => $$"""
        using System;
        using HasFlagExtension;

        namespace TestNamespace;

        [Flags]
        [HasFlagPrefix("{{prefix}}")]
        public enum TestEnum {
            A,
            B,
            C
        }
        """;

    private string GetGeneratedClass(string prefix) => $$"""
        // <auto-generated/>
        
        using System; 
        using System.Diagnostics.Contracts;
        
        namespace TestNamespace {
        
            public static partial class TestEnumExtensions {
        
                /// <summary>
                /// Returns true if any of the bits for A are set in the value.
                /// </summary>
                [Pure]
                public static bool Get{{prefix}}A(this TestEnum value) => value.HasFlag(TestEnum.A);
        
                /// <summary>
                /// Returns true if any of the bits for B are set in the value.
                /// </summary>
                [Pure]
                public static bool Get{{prefix}}B(this TestEnum value) => value.HasFlag(TestEnum.B);
        
                /// <summary>
                /// Returns true if any of the bits for C are set in the value.
                /// </summary>
                [Pure]
                public static bool Get{{prefix}}C(this TestEnum value) => value.HasFlag(TestEnum.C);
        
        #if NET10_0_OR_GREATER
        
                extension(TestEnum value) {
        
                    /// <summary>
                    /// Returns true if any of the bits for A are set in the value.
                    /// </summary>
                    public bool {{prefix}}A => value.HasFlag(TestEnum.A);
        
                    /// <summary>
                    /// Returns true if any of the bits for B are set in the value.
                    /// </summary>
                    public bool {{prefix}}B => value.HasFlag(TestEnum.B);
        
                    /// <summary>
                    /// Returns true if any of the bits for C are set in the value.
                    /// </summary>
                    public bool {{prefix}}C => value.HasFlag(TestEnum.C);
                }
        
        #endif
        
            }
        }
        """;

    [Theory]
    [InlineData("Has")] // TODO: figure out why the frikin generator doesn't work with nothing else but 'Has' in tests
    // [InlineData("Allow")]
    public void GenerateHasFlagMethods(string prefix) {
        var generator = new HasFlagGenerator();
        
        var driver = CSharpGeneratorDriver.Create(generator);

        var compilation = CSharpCompilation.Create(nameof(HasFlagGeneratorTests),
            [CSharpSyntaxTree.ParseText(GetTestEnumClass(prefix))],
            [MetadataReference.CreateFromFile(typeof(object).Assembly.Location)]
        );
        
        var runResult           = driver.RunGenerators(compilation).GetRunResult();
        var generatedFileSyntax = runResult.GeneratedTrees.Single(t => t.FilePath.EndsWith("Extensions.g.cs"));

        _testOutputHelper.WriteLine(generatedFileSyntax.GetText().ToString());
        _testOutputHelper.WriteLine(GetTestEnumClass(prefix));
        
        Assert.Equal(GetGeneratedClass(prefix), generatedFileSyntax.GetText().ToString(), 
            ignoreLineEndingDifferences: true, ignoreWhiteSpaceDifferences: true);
    }
}