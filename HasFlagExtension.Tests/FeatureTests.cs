using System.Linq;
using HasFlagExtension.Generator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;
using Xunit.Abstractions;

namespace HasFlagExtension.Tests;

public class FeatureTests {
    
    private readonly ITestOutputHelper _testOutputHelper;
    public FeatureTests(ITestOutputHelper testOutputHelper) {
        _testOutputHelper = testOutputHelper;
    }
    
    private const string ATTRIBUTE_SOURCE = 
        """
        using System;

        namespace HasFlagExtension;

        internal enum NamingCase : byte {
            CAMEL = 0,
            PASCAL = 1,
            SNAKE = 2,
            SCREAMING_SNAKE = 3,
            KEBAB = 4,
            SPACED_CAMEL = 5,
            TRAIN = 6,
            UNKNOWN
        }

        [AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Enum)]
        internal class EnumNamingAttribute : Attribute {
            public NamingCase EnumNamingCase { get; }
            public NamingCase MethodNamingCase { get; }
            
            public EnumNamingAttribute(NamingCase enumNamingCase, NamingCase methodNamingCase) {
                EnumNamingCase = enumNamingCase;
                MethodNamingCase = methodNamingCase;
            }
        }

        [AttributeUsage(AttributeTargets.Enum)]
        internal class ExcludeFlagEnumAttribute : Attribute {
            public bool Exclude { get; }
            public ExcludeFlagEnumAttribute(bool exclude = true) {
                Exclude = exclude;
            }
        }

        [AttributeUsage(AttributeTargets.Field)]
        internal class ExcludeFlagAttribute : Attribute {
            public bool Exclude { get; }
            public ExcludeFlagAttribute(bool exclude = true) {
                Exclude = exclude;
            }
        }

        [AttributeUsage(AttributeTargets.Enum | AttributeTargets.Field)]
        internal class HasFlagPrefixAttribute : Attribute {
            public string Prefix { get; }
            public HasFlagPrefixAttribute(string prefix) {
                Prefix = prefix;
            }
        }

        [AttributeUsage(AttributeTargets.Field)]
        internal class FlagDisplayNameAttribute : Attribute {
            public string DisplayName { get; }
            public FlagDisplayNameAttribute(string displayName) {
                DisplayName = displayName;
            }
        }

        [AttributeUsage(AttributeTargets.Enum | AttributeTargets.Field, AllowMultiple = true)]
        internal class FlagGroupAttribute : Attribute {
            public string Group { get; }
            public string Prefix { get; }
            
            public FlagGroupAttribute(string group) {
                Group = group;
                Prefix = string.Empty;
            }
            
            public FlagGroupAttribute(string group, string prefix) {
                Group = group;
                Prefix = prefix;
            }
        }
        """;

    [Fact]
    public void ExcludeEnumAttribute_ShouldPreventGeneration() {
        var source = """
            using System;
            using HasFlagExtension;

            namespace TestNamespace;

            [Flags]
            [ExcludeFlagEnum]
            public enum TestEnum {
                A, B
            }
            """;

        RunGenerator(source, out var outputComp);
        
        var generatedTrees = outputComp.SyntaxTrees.Where(t => t.FilePath.EndsWith("Extensions.g.cs")).ToList();
        Assert.Empty(generatedTrees);
    }

    [Fact]
    public void ExcludeFlagAttribute_ShouldExcludeSpecificMember() {
        var source = """
            using System;
            using HasFlagExtension;

            namespace TestNamespace;

            [Flags]
            public enum TestEnum {
                A,
                [ExcludeFlag]
                B,
                C
            }
            """;

        var expected = """
            // <auto-generated>
            //    This code was generated by the HasFlagExtension.Generator (c) 2026 KryKom.
            //    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
            // </auto-generated>

            using System.Diagnostics.Contracts;
            using System.Runtime.CompilerServices;
            using TestNamespace;

            namespace TestNamespace;

            public static partial class TestEnumExtensions {          

                /// <summary>
                /// Returns true if the flag A is present in the value.
                /// </summary>
                [Pure]
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                public static bool GetHasA(this global::TestNamespace.TestEnum val) => val.HasFlag(global::TestNamespace.TestEnum.A);

                /// <summary>
                /// Returns true if the flag C is present in the value.
                /// </summary>
                [Pure]
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                public static bool GetHasC(this global::TestNamespace.TestEnum val) => val.HasFlag(global::TestNamespace.TestEnum.C);

            #if NET10_0_OR_GREATER

                extension (global::TestNamespace.TestEnum val) {

                         /// <summary>
                         /// Returns true if the flag A is present in the value.
                         /// </summary>
                         [Pure]
                         public bool HasA => val.HasFlag(global::TestNamespace.TestEnum.A);

                         /// <summary>
                         /// Returns true if the flag C is present in the value.
                         /// </summary>
                         [Pure]
                         public bool HasC => val.HasFlag(global::TestNamespace.TestEnum.C);
                }
            #endif

            }
            """;

        VerifyGeneratedCode(source, expected);
    }

    [Fact]
    public void FlagDisplayNameAttribute_ShouldOverrideName() {
         var source = """
            using System;
            using HasFlagExtension;

            namespace TestNamespace;

            [Flags]
            public enum TestEnum {
                [FlagDisplayName("IsA")]
                A,
                B
            }
            """;
         
         var expectedFragment = "bool GetHasIsA(this global::TestNamespace.TestEnum val)";
         var expectedFragment2 = "bool HasIsA => val.HasFlag(global::TestNamespace.TestEnum.A)";

         RunGenerator(source, out var outputComp);
         var generatedText = GetGeneratedText(outputComp);
         
         Assert.Contains(expectedFragment, generatedText);
         Assert.Contains(expectedFragment2, generatedText);
    }

    [Fact]
    public void HasFlagPrefixAttribute_OnField_ShouldOverridePrefix() {
         var source = """
            using System;
            using HasFlagExtension;

            namespace TestNamespace;

            [Flags]
            public enum TestEnum {
                [HasFlagPrefix("Is")]
                A,
                B
            }
            """;
         
         var expectedFragmentA = "bool GetIsA(this global::TestNamespace.TestEnum val)";
         var expectedFragmentB = "bool GetHasB(this global::TestNamespace.TestEnum val)";

         RunGenerator(source, out var outputComp);
         var generatedText = GetGeneratedText(outputComp);
         
         Assert.Contains(expectedFragmentA, generatedText);
         Assert.Contains(expectedFragmentB, generatedText);
    }

    [Fact]
    public void EnumNamingAttribute_ShouldTransformNames() {
         var source = """
            using System;
            using HasFlagExtension;

            namespace TestNamespace;

            [Flags]
            [EnumNaming(NamingCase.SCREAMING_SNAKE, NamingCase.PASCAL)]
            public enum TestEnum {
                FLAG_ONE,
                FLAG_TWO
            }
            """;
         
         var expectedFragment1 = "bool GetHasFlagOne(this global::TestNamespace.TestEnum val)";
         var expectedFragment2 = "bool GetHasFlagTwo(this global::TestNamespace.TestEnum val)";

         RunGenerator(source, out var outputComp);
         var generatedText = GetGeneratedText(outputComp);
         
         Assert.Contains(expectedFragment1, generatedText);
         Assert.Contains(expectedFragment2, generatedText);
    }

    [Fact]
    public void IsGroupExtensionGenerator_ShouldGenerateGroupMethods()
    {
        var source = """
            using System;
            using HasFlagExtension;

            namespace TestNamespace;

            [FlagGroup("Read")]
            [FlagGroup("Write")]
            public enum TestEnum {
                [FlagGroup("Read")]
                A,
                [FlagGroup("Read")]
                B,
                [FlagGroup("Write")]
                C
            }
            """;

        var expected = """
            // <auto-generated>
            //    This code was generated by the HasFlagExtension.Generator (c) 2026 KryKom.
            //    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
            // </auto-generated>

            using System.Diagnostics.Contracts;
            using System.Runtime.CompilerServices;
            using TestNamespace;

            namespace TestNamespace;

            public static partial class TestEnumExtensions {

                /// <summary>
                /// Returns true if the enum value is a member of the 'Read' group.
                /// </summary>
                [Pure]
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                public static bool GetIsRead(this global::TestNamespace.TestEnum val) 
                    => val is global::TestNamespace.TestEnum.A or global::TestNamespace.TestEnum.B;
                /// <summary>
                /// Returns true if the enum value is a member of the 'Write' group.
                /// </summary>
                [Pure]
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                public static bool GetIsWrite(this global::TestNamespace.TestEnum val) 
                    => val is global::TestNamespace.TestEnum.C;
            
            #if DOTNET_10_OR_GREATER

                extension(global::TestNamespace.TestEnum val) {

                    /// <summary>
                    /// Returns true if the enum value is a member of the 'Read' group.
                    /// </summary>
                    [Pure]
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public bool IsRead 
                        => val is global::TestNamespace.TestEnum.A or global::TestNamespace.TestEnum.B;
                    /// <summary>
                    /// Returns true if the enum value is a member of the 'Write' group.
                    /// </summary>
                    [Pure]
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public bool IsWrite 
                        => val is global::TestNamespace.TestEnum.C;
                }
                
            #endif
                
            }

            """;

        VerifyGroupGeneratedCode(source, expected);
    }

    private void VerifyGroupGeneratedCode(string source, string expected)
    {
        RunGroupGenerator(source, out var outputComp);
        var generatedText = GetGeneratedText(outputComp);
        
        Assert.Equal(expected, generatedText,
            ignoreLineEndingDifferences: true, ignoreWhiteSpaceDifferences: true, ignoreAllWhiteSpace: true);
    }

    private void RunGroupGenerator(string source, out Compilation outputCompilation)
    {
        var generator = new IsGroupExtensionGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);

        var compilation = CSharpCompilation.Create("TestCompilation",
            new[]
            {
                CSharpSyntaxTree.ParseText(ATTRIBUTE_SOURCE),
                CSharpSyntaxTree.ParseText(source),
            },
            new[]
            {
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location)
            });

        driver.RunGeneratorsAndUpdateCompilation(compilation, out outputCompilation, out var diagnostics);

        var errors = diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error).ToList();
        if (errors.Any())
        {
            _testOutputHelper.WriteLine("Generator errors: " + string.Join("\n", errors));
            throw new System.Exception("Generator errors occurred. See output.");
        }
    }

    private void VerifyGeneratedCode(string source, string expected) {
        RunGenerator(source, out var outputComp);
        var generatedText = GetGeneratedText(outputComp);
        
        Assert.Equal(expected, generatedText, 
             ignoreLineEndingDifferences: true, ignoreWhiteSpaceDifferences: true, ignoreAllWhiteSpace: true);
    }

    private string GetGeneratedText(Compilation compilation) {
        var generatedTree = compilation.SyntaxTrees.Single(t => t.FilePath.EndsWith("TestEnumExtensions.g.cs"));
        return generatedTree.GetText().ToString();
    }

    private void RunGenerator(string source, out Compilation outputCompilation) {
        var generator = new HasFlagExtensionGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        
        var compilation = CSharpCompilation.Create("TestCompilation",
            [
                CSharpSyntaxTree.ParseText(ATTRIBUTE_SOURCE),
                CSharpSyntaxTree.ParseText(source),
            ],
            [
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location)
            ]
        );
        
        driver.RunGeneratorsAndUpdateCompilation(compilation, out outputCompilation, out var diagnostics);
        
        // Fail if there are generator errors (except info/warnings if expected, but generally clean)
        var errors = diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error).ToList();
        if (errors.Any()) {
            _testOutputHelper.WriteLine("Generator errors: " + string.Join("\n", errors));
            throw new System.Exception("Generator errors occurred. See output.");
        }
    }
}
