using System.Linq;
using HasFlagExtension.Generator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;
using Xunit.Abstractions;

namespace HasFlagExtension.Tests;

public class FeatureTests {
    
    private readonly ITestOutputHelper _testOutputHelper;
    public FeatureTests(ITestOutputHelper testOutputHelper) {
        _testOutputHelper = testOutputHelper;
    }
    
    private const string ATTRIBUTE_SOURCE = 
        """
        using System;

        namespace HasFlagExtension;

        internal enum NamingCase : byte {
            CAMEL = 0,
            PASCAL = 1,
            SNAKE = 2,
            SCREAMING_SNAKE = 3,
            KEBAB = 4,
            SPACED_CAMEL = 5,
            TRAIN = 6,
            UNKNOWN
        }

        [AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Enum)]
        internal class EnumNamingAttribute : Attribute {
            public NamingCase EnumNamingCase { get; }
            public NamingCase MethodNamingCase { get; }
            
            public EnumNamingAttribute(NamingCase enumNamingCase, NamingCase methodNamingCase) {
                EnumNamingCase = enumNamingCase;
                MethodNamingCase = methodNamingCase;
            }
        }

        [AttributeUsage(AttributeTargets.Enum)]
        internal class ExcludeFlagEnumAttribute : Attribute {
            public bool Exclude { get; }
            public ExcludeFlagEnumAttribute(bool exclude = true) {
                Exclude = exclude;
            }
        }

        [AttributeUsage(AttributeTargets.Field)]
        internal class ExcludeFlagAttribute : Attribute {
            public bool Exclude { get; }
            public ExcludeFlagAttribute(bool exclude = true) {
                Exclude = exclude;
            }
        }

        [AttributeUsage(AttributeTargets.Enum | AttributeTargets.Field)]
        internal class HasFlagPrefixAttribute : Attribute {
            public string Prefix { get; }
            public HasFlagPrefixAttribute(string prefix) {
                Prefix = prefix;
            }
        }

        [AttributeUsage(AttributeTargets.Field)]
        internal class FlagDisplayNameAttribute : Attribute {
            public string DisplayName { get; }
            public FlagDisplayNameAttribute(string displayName) {
                DisplayName = displayName;
            }
        }
        """;

    [Fact]
    public void ExcludeEnumAttribute_ShouldPreventGeneration() {
        var source = """
            using System;
            using HasFlagExtension;

            namespace TestNamespace;

            [Flags]
            [ExcludeFlagEnum]
            public enum TestEnum {
                A, B
            }
            """;

        RunGenerator(source, out var outputComp);
        
        var generatedTrees = outputComp.SyntaxTrees.Where(t => t.FilePath.EndsWith("Extensions.g.cs")).ToList();
        Assert.Empty(generatedTrees);
    }

    [Fact]
    public void ExcludeFlagAttribute_ShouldExcludeSpecificMember() {
        var source = """
            using System;
            using HasFlagExtension;

            namespace TestNamespace;

            [Flags]
            public enum TestEnum {
                A,
                [ExcludeFlag]
                B,
                C
            }
            """;

        var expected = """
            // <auto-generated />

            using System.Diagnostics.Contracts;
            using System.Runtime.CompilerServices;
            using TestNamespace;

            namespace TestNamespace;

            public static partial class TestEnumExtensions {          

                /// <summary>
                /// Returns true if the flag A is present in the value.
                /// </summary>
                [Pure]
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                public static bool GetHasA(this TestNamespace.TestEnum val) => val.HasFlag(TestNamespace.TestEnum.A);

                /// <summary>
                /// Returns true if the flag C is present in the value.
                /// </summary>
                [Pure]
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                public static bool GetHasC(this TestNamespace.TestEnum val) => val.HasFlag(TestNamespace.TestEnum.C);

            #if NET10_0_OR_GREATER

                extension (TestNamespace.TestEnum val) {

                         /// <summary>
                         /// Returns true if the flag A is present in the value.
                         /// </summary>
                         [Pure]
                         public bool HasA => val.HasFlag(TestNamespace.TestEnum.A);

                         /// <summary>
                         /// Returns true if the flag C is present in the value.
                         /// </summary>
                         [Pure]
                         public bool HasC => val.HasFlag(TestNamespace.TestEnum.C);
                }
            #endif

            }
            """;

        VerifyGeneratedCode(source, expected);
    }

    [Fact]
    public void FlagDisplayNameAttribute_ShouldOverrideName() {
         var source = """
            using System;
            using HasFlagExtension;

            namespace TestNamespace;

            [Flags]
            public enum TestEnum {
                [FlagDisplayName("IsA")]
                A,
                B
            }
            """;
         
         var expectedFragment = "bool GetHasIsA(this TestNamespace.TestEnum val)";
         var expectedFragment2 = "bool HasIsA => val.HasFlag";

         RunGenerator(source, out var outputComp);
         var generatedText = GetGeneratedText(outputComp);
         
         Assert.Contains(expectedFragment, generatedText);
         Assert.Contains(expectedFragment2, generatedText);
    }

    [Fact]
    public void HasFlagPrefixAttribute_OnField_ShouldOverridePrefix() {
         var source = """
            using System;
            using HasFlagExtension;

            namespace TestNamespace;

            [Flags]
            public enum TestEnum {
                [HasFlagPrefix("Is")]
                A,
                B
            }
            """;
         
         var expectedFragmentA = "bool GetIsA(this TestNamespace.TestEnum val)";
         var expectedFragmentB = "bool GetHasB(this TestNamespace.TestEnum val)";

         RunGenerator(source, out var outputComp);
         var generatedText = GetGeneratedText(outputComp);
         
         Assert.Contains(expectedFragmentA, generatedText);
         Assert.Contains(expectedFragmentB, generatedText);
    }

    [Fact]
    public void EnumNamingAttribute_ShouldTransformNames() {
         var source = """
            using System;
            using HasFlagExtension;

            namespace TestNamespace;

            [Flags]
            [EnumNaming(NamingCase.SCREAMING_SNAKE, NamingCase.PASCAL)]
            public enum TestEnum {
                FLAG_ONE,
                FLAG_TWO
            }
            """;
         
         var expectedFragment1 = "bool GetHasFlagOne(this TestNamespace.TestEnum val)";
         var expectedFragment2 = "bool GetHasFlagTwo(this TestNamespace.TestEnum val)";

         RunGenerator(source, out var outputComp);
         var generatedText = GetGeneratedText(outputComp);
         
         Assert.Contains(expectedFragment1, generatedText);
         Assert.Contains(expectedFragment2, generatedText);
    }

    private void VerifyGeneratedCode(string source, string expected) {
        RunGenerator(source, out var outputComp);
        var generatedText = GetGeneratedText(outputComp);
        
        Assert.Equal(expected, generatedText, 
             ignoreLineEndingDifferences: true, ignoreWhiteSpaceDifferences: true, ignoreAllWhiteSpace: true);
    }

    private string GetGeneratedText(Compilation compilation) {
        var generatedTree = compilation.SyntaxTrees.Single(t => t.FilePath.EndsWith("Extensions.g.cs"));
        return generatedTree.GetText().ToString();
    }

    private void RunGenerator(string source, out Compilation outputCompilation) {
        var generator = new HasFlagExtensionGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        
        var compilation = CSharpCompilation.Create("TestCompilation",
            [
                CSharpSyntaxTree.ParseText(ATTRIBUTE_SOURCE),
                CSharpSyntaxTree.ParseText(source),
            ],
            [
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location)
            ]
        );
        
        driver.RunGeneratorsAndUpdateCompilation(compilation, out outputCompilation, out var diagnostics);
        
        // Fail if there are generator errors (except info/warnings if expected, but generally clean)
        var errors = diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error).ToList();
        if (errors.Any()) {
            _testOutputHelper.WriteLine("Generator errors: " + string.Join("\n", errors));
            throw new System.Exception("Generator errors occurred. See output.");
        }
    }
}
